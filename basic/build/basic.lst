
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -b --mr65c02 -Wall -L build/basic.lst -o build/basic.bin basic.asm
; Thu Nov 30 09:46:21 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm

.c000	4c 03 c0	jmp $c003	boot:	jmp 	cold
.c003					cold:
.c003	a9 00		lda #$00			lda 	#(Program & $FF)
.c005	85 3a		sta $3a				sta 	codePtr
.c007	a9 c5		lda #$c5			lda 	#(Program >> 8)+1
.c009	85 3b		sta $3b				sta 	codePtr+1
.c00b	a0 04		ldy #$04			ldy 	#4
.c00d	20 14 c0	jsr $c014			jsr 	EXPEvaluateExpressionRestart
>c010	03						.byte 	3
.c011	80 fe		bra $c011	h1:		bra 	h1

;******  Processing file: _include.inc


;******  Processing file: sources/00data/00data_config.inc


;******  Return to file: _include.inc


;******  Processing file: sources/00data/01data.inc

=8					StackSize = 8
=$c0					XS_TYPEMASK = $C0
=$80					XS_TYPEBIT = $80
=$20					XS_ISREFERENCE = $20
=$10					XS_ISBYTEREFERENCE = $10
.0010					XSStack:
.0010					XSControl:
>0010							.fill 	StackSize
.0018					XSNumber0:
>0018							.fill 	StackSize
.0020					XSNumber1:
>0020							.fill 	StackSize
.0028					XSNumber2:
>0028							.fill 	StackSize
.0030					XSNumber3:
>0030							.fill 	StackSize
.0038					zTemp0:
>0038							.fill 	2
.003a					CodePtr:
>003a							.fill 	2

;******  Return to file: _include.inc


;******  Processing file: sources/generated/errors.inc


;******  Return to file: _include.inc


;******  Processing file: sources/generated/kwdconst.inc

=$20					KWD_PLUS                           = $20 ; +
=$21					KWD_MINUS                          = $21 ; -
=$22					KWD_ASTERISK                       = $22 ; *
=$23					KWD_SLASH                          = $23 ; /
=$24					KWD_GREATERGREATER                 = $24 ; >>
=$25					KWD_LESSLESS                       = $25 ; <<
=$26					KWD_PERCENT                        = $26 ; %
=$27					KWD_BACKSLASH                      = $27 ; \
=$28					KWD_AMPERSAND                      = $28 ; &
=$29					KWD_VBAR                           = $29 ; |
=$2a					KWD_HAT                            = $2a ; ^
=$2b					KWD_GREATER                        = $2b ; >
=$2c					KWD_GREATEREQUAL                   = $2c ; >=
=$2d					KWD_LESS                           = $2d ; <
=$2e					KWD_LESSEQUAL                      = $2e ; <=
=$2f					KWD_LESSGREATER                    = $2f ; <>
=$30					KWD_EQUAL                          = $30 ; =
=$31					KWD_PLING                          = $31 ; !
=$32					KWD_QMARK                          = $32 ; ?
=$80					KWD_SYS_STR                        = $80 ; !!str
=$81					KWD_DOLLAR                         = $81 ; $
=$82					KWD_LPAREN                         = $82 ; (
=$83					KWD_RANDLPAREN                     = $83 ; rand(
=$84					KWD_RNDLPAREN                      = $84 ; rnd(
=$85					KWD_ISVALLPAREN                    = $85 ; isval(
=$86					KWD_FRACLPAREN                     = $86 ; frac(
=$87					KWD_INTLPAREN                      = $87 ; int(
=$88					KWD_TIME                           = $88 ; time
=$89					KWD_EVENTLPAREN                    = $89 ; event(
=$8a					KWD_INKEYDOLLARLPAREN              = $8a ; inkey$(
=$8b					KWD_ASCLPAREN                      = $8b ; asc(
=$8c					KWD_CHRDOLLARLPAREN                = $8c ; chr$(
=$8d					KWD_SQRLPAREN                      = $8d ; sqr(
=$8e					KWD_LENLPAREN                      = $8e ; len(
=$8f					KWD_ABSLPAREN                      = $8f ; abs(
=$90					KWD_SGNLPAREN                      = $90 ; sgn(
=$91					KWD_VALLPAREN                      = $91 ; val(
=$92					KWD_STRDOLLARLPAREN                = $92 ; str$(
=$93					KWD_MIDDOLLARLPAREN                = $93 ; mid$(
=$94					KWD_LEFTDOLLARLPAREN               = $94 ; left$(
=$95					KWD_RIGHTDOLLARLPAREN              = $95 ; right$(
=$96					KWD_SINLPAREN                      = $96 ; sin(
=$97					KWD_COSLPAREN                      = $97 ; cos(
=$98					KWD_TANLPAREN                      = $98 ; tan(
=$99					KWD_ATANLPAREN                     = $99 ; atan(
=$9a					KWD_SQRTLPAREN                     = $9a ; sqrt(
=$9b					KWD_LOGLPAREN                      = $9b ; log(
=$9c					KWD_EXPLPAREN                      = $9c ; exp(
=$9d					KWD_KEYLPAREN                      = $9d ; key(
=$b0					KWD_WHILE                          = $b0 ; while
=$b1					KWD_WEND                           = $b1 ; wend
=$b2					KWD_IF                             = $b2 ; if
=$b3					KWD_ENDIF                          = $b3 ; endif
=$b4					KWD_DO                             = $b4 ; do
=$b5					KWD_LOOP                           = $b5 ; loop
=$b6					KWD_REPEAT                         = $b6 ; repeat
=$b7					KWD_UNTIL                          = $b7 ; until
=$b8					KWD_PROC                           = $b8 ; proc
=$b9					KWD_ENDPROC                        = $b9 ; endproc
=$ba					KWD_FOR                            = $ba ; for
=$bb					KWD_NEXT                           = $bb ; next
=$bc					KWD_CASE                           = $bc ; case
=$bd					KWD_ENDCASE                        = $bd ; endcase
=$be					KWD_SYS_UN1                        = $be ; !!un1
=$bf					KWD_THEN                           = $bf ; then
=$c0					KWD_SYS_END                        = $c0 ; !!end
=$c1					KWD_SYS_SH1                        = $c1 ; !!sh1
=$c2					KWD_SYS_SH2                        = $c2 ; !!sh2
=$c3					KWD_SYS_DEC                        = $c3 ; !!dec
=$c4					KWD_TO                             = $c4 ; to
=$c5					KWD_LET                            = $c5 ; let
=$c6					KWD_PRINT                          = $c6 ; print
=$c7					KWD_INPUT                          = $c7 ; input
=$c8					KWD_CALL                           = $c8 ; call
=$c9					KWD_SYS                            = $c9 ; sys
=$ca					KWD_EXIT                           = $ca ; exit
=$cb					KWD_COMMA                          = $cb ; ,
=$cc					KWD_SEMICOLON                      = $cc ; ;
=$cd					KWD_COLON                          = $cd ; :
=$ce					KWD_SQUOTE                         = $ce ; '
=$cf					KWD_RPAREN                         = $cf ; )
=$d0					KWD_READ                           = $d0 ; read
=$d1					KWD_DATA                           = $d1 ; data
=$d2					KWD_LSQ                            = $d2 ; [
=$d3					KWD_RSQ                            = $d3 ; ]
=$d4					KWD_HASH                           = $d4 ; #
=$d5					KWD_PERIOD                         = $d5 ; .
=$d6					KWD_ELSE                           = $d6 ; else
=$d7					KWD_WHEN                           = $d7 ; when
=$d8					KWD_DOWNTO                         = $d8 ; downto
=$100					KWD_CLEAR                          = $100 ; clear
=$101					KWD_NEW                            = $101 ; new
=$102					KWD_RUN                            = $102 ; run
=$103					KWD_STOP                           = $103 ; stop
=$104					KWD_END                            = $104 ; end
=$105					KWD_ASSERT                         = $105 ; assert
=$106					KWD_LIST                           = $106 ; list
=$107					KWD_SAVE                           = $107 ; save
=$108					KWD_LOAD                           = $108 ; load
=$109					KWD_GOSUB                          = $109 ; gosub
=$10a					KWD_GOTO                           = $10a ; goto
=$10b					KWD_RETURN                         = $10b ; return
=$10c					KWD_RESTORE                        = $10c ; restore
=$10d					KWD_DIM                            = $10d ; dim

;******  Return to file: _include.inc


;******  Processing file: sources/generated/neo6502.inc

=$ff00					ControlPort = $ff00
=$ffee					ReadCharacter = $ffee
=$fff1					WriteCharacter = $fff1
=$fff4					WaitMessage = $fff4
=$fff7					SendMessage = $fff7

;******  Return to file: _include.inc


;******  Processing file: sources/arithmetic/dereference.asm

.c013					DereferenceTerm:
.c013	60		rts				rts

;******  Return to file: _include.inc


;******  Processing file: sources/arithmetic/expression.asm

.c014					EXPEvaluateExpressionRestart:
.c014	a2 00		ldx #$00			ldx 	#0 							; start from base of stack.
.c016					EXPEvaluateExpression:
.c016	a9 00		lda #$00			lda 	#0 							; current precedence is 0.
.c018					EXPEvaluateExpressionPrecedenceA:
.c018	48		pha				pha		 							; push on stack.
.c019	20 64 c0	jsr $c064			jsr 	EvaluateTerm 				; evaluate term at this level.
.c01c					EXPRMainLoop:
.c01c	b1 3a		lda ($3a),y			lda 	(codePtr),y 				; what follows needs to be a binary operator
.c01e	29 e0		and #$e0			and 	#$E0 						; is it $20-$3F, e.g. a binary operator.
.c020	c9 20		cmp #$20			cmp 	#$20
.c022	d0 2e		bne $c052			bne 	_EEExit
.c024	da		phx				phx 			 					; get binary precedence for current operator -> zTemp0+1
.c025	b1 3a		lda ($3a),y			lda 	(codePtr),y 				; get the operator again
.c027	aa		tax				tax
.c028	bd 32 c3	lda $c332,x			lda 	BinaryPrecedence-$20,x 		; get the binary operator precedence.
.c02b	85 39		sta $39				sta 	zTemp0+1
.c02d	fa		plx				plx
.c02e	68		pla				pla 								; restore current precedence.
.c02f	c5 39		cmp $39				cmp 	zTemp0+1 					; if >= operator precedence then exit
.c031	b0 20		bcs $c053			bcs 	_EEExit2
.c033	48		pha				pha 								; save current precedence on the 6502 stack.
.c034	b1 3a		lda ($3a),y			lda 	(codePtr),y 				; get the operator back.
.c036	c8		iny				iny 								; consume operator.
.c037	48		pha				pha 								; save the operator.
.c038	a5 39		lda $39				lda 	zTemp0+1					; get precedence of operator
.c03a	e8		inx				inx 								; space for it on the stack and do the RHS.
.c03b	20 18 c0	jsr $c018			jsr 	EXPEvaluateExpressionPrecedenceA
.c03e	ca		dex				dex 								; back to original value.
.c03f	68		pla				pla 								; load operator
.c040	29 1f		and #$1f			and 	#$1F 						; mask out bits
.c042	0a		asl a				asl 	a 							; double as look up table, also Clear Carry
.c043	69 65		adc #$65			adc 	#(BinaryVectorTable & $FF) 	; work out the address to do the indirect jump.
.c045	8d 50 c0	sta $c050			sta 	_EXPRIndirectJump+1
.c048	a9 c3		lda #$c3			lda 	#(BinaryVectorTable >> 8)
.c04a	69 00		adc #$00			adc 	#0
.c04c	8d 51 c0	sta $c051			sta 	_EXPRIndirectJump+2
.c04f					_EXPRIndirectJump:
.c04f	6c ff ff	jmp ($ffff)			jmp 	($FFFF) 					; jump to the code routine, loops back to EXPRMainLoop
.c052					_EEExit:
.c052	68		pla				pla 								; throw precedence
.c053					_EEExit2:
.c053	60		rts				rts
.c054					SysTestMinus:
.c054	a9 01		lda #$01			lda 	#1
.c056	20 3f c1	jsr $c13f			jsr 	DoMathCommand
.c059	4c 1c c0	jmp $c01c			jmp 	EXPRMainLoop
.c05c					SysTestTimes:
.c05c	a9 02		lda #$02			lda 	#2
.c05e	20 3f c1	jsr $c13f			jsr 	DoMathCommand
.c061	4c 1c c0	jmp $c01c			jmp 	EXPRMainLoop

;******  Return to file: _include.inc


;******  Processing file: sources/arithmetic/term.asm

.c064					EvaluateTerm:
.c064	b1 3a		lda ($3a),y			lda 	(CodePtr),y 				; get next token
.c066	30 0a		bmi $c072			bmi 	_ETKeyword 					; is it a keyword (80-FF) ?
.c068	0a		asl a				asl		a							; is it a number (40-7F)
.c069	10 08		bpl $c073			bpl		_ETIdentifierOrSpecial 		; if 00-3F then it is an identifier, or a multi purpose unary ! ? -
.c06b	20 d8 c0	jsr $c0d8			jsr 	ExtractTokenisedInteger
.c06e	20 1e c1	jsr $c11e			jsr 	CheckFollowingDecimal
.c071	60		rts				rts
.c072					_ETKeyword:
>c072	03						.byte 	3
.c073					_ETIdentifierOrSpecial:
.c073	0a		asl a			 	asl 	a 							; bit 5 now in sign slot
.c074	10 40		bpl $c0b6		 	bpl 	_ETIsIdentifier  			; 0 it is 00-1F e.g. identifier
.c076	b1 3a		lda ($3a),y		 	lda 	(codePtr),y 				; get and consume. clearer than reuse
.c078	c8		iny			 	iny
.c079	c9 21		cmp #$21		 	cmp 	#KWD_MINUS 					; negation.
.c07b	d0 10		bne $c08d		 	bne 	_ETCheckReference
.c07d	20 64 c0	jsr $c064		 	jsr 	EvaluateTerm 				; it's minus *something*.
.c080	20 13 c0	jsr $c013		 	jsr 	DereferenceTerm 			; dereference it.
.c083	b5 10		lda $10,x		 	lda 	XSControl,x 				; numeric term ?
.c085	30 2a		bmi $c0b1		 	bmi 	_ETBadType
.c087	a9 10		lda #$10		 	lda 	#16 						; negation function - needs optimising for ints
.c089	20 3f c1	jsr $c13f		 	jsr 	DoMathCommand 				; work it out
.c08c	60		rts			 	rts
.c08d					_ETCheckReference:
.c08d	c9 32		cmp #$32			cmp 	#KWD_QMARK
.c08f	f0 09		beq $c09a			beq 	_ETHaveReference
.c091	49 31		eor #$31			eor 	#KWD_PLING
.c093	f0 05		beq $c09a			beq 	_ETHaveReference
.c095	a9 01		lda #$01		lda	#1
.c097	4c 0d c5	jmp $c50d		jmp	ErrorHandler
.c09a					_ETHaveReference:
.c09a	48		pha				pha 								; save type.
.c09b	20 64 c0	jsr $c064		 	jsr 	EvaluateTerm 				; get reference address
.c09e	20 13 c0	jsr $c013		 	jsr 	DereferenceTerm
.c0a1	b5 10		lda $10,x		 	lda 	XSControl,x 				; must be integer
.c0a3	29 c0		and #$c0		 	and 	#XS_TYPEMASK
.c0a5	d0 0a		bne $c0b1		 	bne 	_ETBadType
.c0a7	68		pla			 	pla 								; get type of reference back
.c0a8	f0 02		beq $c0ac		 	beq 	_ETIsWord 					; if zero, it's a word reference
.c0aa	a9 10		lda #$10		 	lda 	#XS_ISBYTEREFERENCE
.c0ac					_ETIsWord:
.c0ac	09 20		ora #$20			ora 	#XS_ISREFERENCE 			; now $20 / $30 for word/byte reference
.c0ae	95 10		sta $10,x			sta 	XSControl,x 				; update type
.c0b0	60		rts				rts
.c0b1					_ETBadType:
.c0b1	a9 02		lda #$02		lda	#2
.c0b3	4c 0d c5	jmp $c50d		jmp	ErrorHandler
.c0b6					_ETIsIdentifier:
>c0b6	03						.byte 	3
.c0b7	b1 3a		lda ($3a),y			lda 	(codePtr),y 				; get the MSB of the identifier address.
.c0b9	c8		iny				iny
.c0ba	18		clc				clc
.c0bb	69 c4		adc #$c4			adc 	#Program >> 8 				; convert to a real address.
.c0bd	95 20		sta $20,x			sta 	XSNumber1,x
.c0bf	85 39		sta $39				sta 	zTemp0+1
.c0c1	b1 3a		lda ($3a),y			lda 	(codePtr),y 				; LSB - on a page boundary
.c0c3	95 18		sta $18,x			sta 	XSNumber0,x
.c0c5	85 38		sta $38				sta 	zTemp0
.c0c7	74 28		stz $28,x			stz 	XSNumber2,x 				; neatness
.c0c9	74 30		stz $30,x			stz 	XSNumber3,x
.c0cb	5a		phy				phy 								; read and update the type/control
.c0cc	a0 04		ldy #$04			ldy 	#4
.c0ce	b1 38		lda ($38),y			lda 	(zTemp0),y
.c0d0	29 c0		and #$c0			and 	#XS_TYPEMASK 				; type info
.c0d2	09 20		ora #$20			ora 	#XS_ISREFERENCE 			; set reference bit (is word)
.c0d4	7a		ply				ply
.c0d5	95 10		sta $10,x			sta 	XSControl,x
.c0d7	60		rts				rts
.c0d8					ExtractTokenisedInteger:
.c0d8	b1 3a		lda ($3a),y			lda 	(codePtr),y 				; get first token, known to be 40-7F
.c0da	29 3f		and #$3f			and 	#$3F 						; mask off upper bits
.c0dc	95 18		sta $18,x			sta 	XSNumber0,x 				; initial value.
.c0de	74 20		stz $20,x			stz 	XSNumber1,x
.c0e0	74 28		stz $28,x			stz 	XSNumber2,x
.c0e2	74 30		stz $30,x			stz 	XSNumber3,x
.c0e4	74 10		stz $10,x			stz 	XSControl,x 				; integer constant
.c0e6					_ETConstant:
.c0e6	c8		iny				iny 								; look at next
.c0e7	b1 3a		lda ($3a),y			lda 	(CodePtr),y
.c0e9	29 c0		and #$c0			and 	#$C0 						; is it $40..$7F
.c0eb	c9 40		cmp #$40			cmp 	#$40
.c0ed	d0 2e		bne $c11d			bne 	_ETExit
.c0ef	b5 30		lda $30,x			lda 	XSNumber3,x 				; save the upper byte.
.c0f1	48		pha				pha
.c0f2	b5 28		lda $28,x			lda 	XSNumber2,x 				; multiply old by 256
.c0f4	95 30		sta $30,x			sta 	XSNumber3,x
.c0f6	b5 20		lda $20,x			lda 	XSNumber1,x
.c0f8	95 28		sta $28,x			sta 	XSNumber2,x
.c0fa	b5 18		lda $18,x			lda 	XSNumber0,x
.c0fc	95 20		sta $20,x			sta 	XSNumber1,x
.c0fe	74 18		stz $18,x			stz 	XSNumber0,x
.c100	68		pla				pla 								; old MS Byte
.c101	4a		lsr a				lsr 	a 							; shift right twice
.c102	76 30		ror $30,x			ror 	XSNumber3,x
.c104	76 28		ror $28,x			ror 	XSNumber2,x
.c106	76 20		ror $20,x			ror 	XSNumber1,x
.c108	76 18		ror $18,x			ror 	XSNumber0,x
.c10a	4a		lsr a				lsr 	a
.c10b	76 30		ror $30,x			ror 	XSNumber3,x
.c10d	76 28		ror $28,x			ror 	XSNumber2,x
.c10f	76 20		ror $20,x			ror 	XSNumber1,x
.c111	76 18		ror $18,x			ror 	XSNumber0,x
.c113	b1 3a		lda ($3a),y			lda 	(codePtr),y 				; or the lower 6 bits in.
.c115	29 3f		and #$3f			and 	#$3F
.c117	15 18		ora $18,x			ora 	XSNumber0,x
.c119	95 18		sta $18,x			sta 	XSNumber0,x
.c11b	80 c9		bra $c0e6			bra 	_ETConstant
.c11d					_ETExit:
.c11d	60		rts				rts
.c11e					CheckFollowingDecimal:
.c11e	b1 3a		lda ($3a),y			lda 	(CodePtr),y 				; what follows ?
.c120	c9 c3		cmp #$c3			cmp 	#KWD_SYS_DEC 				; decimal ?
.c122	d0 1a		bne $c13e			bne 	_CFDExit
.c124	98		tya				tya 								; get address of decimal data
.c125	1a		inc a				inc 	a
.c126	38		sec				sec
.c127	65 3a		adc $3a				adc 	CodePtr
.c129	8d 08 ff	sta $ff08			sta 	ControlPort+8 				; param slot 2 = address of decimal data.
.c12c	a5 3b		lda $3b				lda 	CodePtr+1
.c12e	69 00		adc #$00			adc 	#0
.c130	8d 09 ff	sta $ff09			sta 	ControlPort+9
.c133	a9 20		lda #$20			lda 	#32 						; decimal expand code.
.c135	20 3f c1	jsr $c13f			jsr 	DoMathCommand
.c138	c8		iny				iny 								; get length and add it +1 for the length
.c139	98		tya				tya
.c13a	38		sec				sec
.c13b	71 3a		adc ($3a),y			adc 	(CodePtr),y
.c13d	a8		tay				tay
.c13e					_CFDExit:
.c13e	60		rts				rts
.c13f					DoMathCommand:
.c13f	48		pha				pha
.c140	20 f4 ff	jsr $fff4		jsr 	WaitMessage
.c143	8d 01 ff	sta $ff01			sta 	ControlPort+1
.c146	8a		txa				txa
.c147	18		clc				clc
.c148	69 10		adc #$10			adc 	#XSStack & $FF
.c14a	8d 04 ff	sta $ff04			sta 	ControlPort+4
.c14d	a9 00		lda #$00			lda 	#XSStack >> 8
.c14f	69 00		adc #$00			adc 	#0
.c151	8d 05 ff	sta $ff05			sta 	ControlPort+5
.c154	a9 08		lda #$08			lda 	#8
.c156	8d 06 ff	sta $ff06			sta 	ControlPort+6
.c159	a9 04		lda #$04			lda 	#4
.c15b	8d 00 ff	sta $ff00			sta 	ControlPort 				; do command
.c15e	20 f4 ff	jsr $fff4		jsr 	WaitMessage
.c161	68		pla				pla				; wait for result.
.c162	60		rts				rts

;******  Return to file: _include.inc


;******  Processing file: sources/generated/errors.asm

.c163					ErrorMessageText:
>c163	73 79 6e 74 61 78 20 65			.text	"syntax error",0
>c16b	72 72 6f 72 00
>c170	74 79 70 65 20 6d 69 73			.text	"type mismatch error",0
>c178	6d 61 74 63 68 20 65 72 72 6f 72 00

;******  Return to file: _include.inc


;******  Processing file: sources/generated/kwdtext.asm

.c184					BinaryTokenText:
>c184	01 ab					.byte	$01,$ab                       	; $ 20 +
>c186	01 ad					.byte	$01,$ad                       	; $ 21 -
>c188	01 aa					.byte	$01,$aa                       	; $ 22 *
>c18a	01 af					.byte	$01,$af                       	; $ 23 /
>c18c	02 3e be				.byte	$02,$3e,$be                   	; $ 24 >>
>c18f	02 3c bc				.byte	$02,$3c,$bc                   	; $ 25 <<
>c192	01 a5					.byte	$01,$a5                       	; $ 26 %
>c194	01 dc					.byte	$01,$dc                       	; $ 27 \
>c196	01 a6					.byte	$01,$a6                       	; $ 28 &
>c198	01 fc					.byte	$01,$fc                       	; $ 29 |
>c19a	01 de					.byte	$01,$de                       	; $ 2a ^
>c19c	01 be					.byte	$01,$be                       	; $ 2b >
>c19e	02 3e bd				.byte	$02,$3e,$bd                   	; $ 2c >=
>c1a1	01 bc					.byte	$01,$bc                       	; $ 2d <
>c1a3	02 3c bd				.byte	$02,$3c,$bd                   	; $ 2e <=
>c1a6	02 3c be				.byte	$02,$3c,$be                   	; $ 2f <>
>c1a9	01 bd					.byte	$01,$bd                       	; $ 30 =
>c1ab	01 a1					.byte	$01,$a1                       	; $ 31 !
>c1ad	01 bf					.byte	$01,$bf                       	; $ 32 ?
>c1af	ff					.byte	$FF
.c1b0					BaseTokenText:
>c1b0	00					.byte	$00                           	; $ 80
>c1b1	01 a4					.byte	$01,$a4                       	; $ 81 $
>c1b3	01 a8					.byte	$01,$a8                       	; $ 82 (
>c1b5	05 52 41 4e 44 a8			.byte	$05,$52,$41,$4e,$44,$a8       	; $ 83 RAND(
>c1bb	04 52 4e 44 a8				.byte	$04,$52,$4e,$44,$a8           	; $ 84 RND(
>c1c0	06 49 53 56 41 4c a8			.byte	$06,$49,$53,$56,$41,$4c,$a8   	; $ 85 ISVAL(
>c1c7	05 46 52 41 43 a8			.byte	$05,$46,$52,$41,$43,$a8       	; $ 86 FRAC(
>c1cd	04 49 4e 54 a8				.byte	$04,$49,$4e,$54,$a8           	; $ 87 INT(
>c1d2	04 54 49 4d c5				.byte	$04,$54,$49,$4d,$c5           	; $ 88 TIME
>c1d7	06 45 56 45 4e 54 a8			.byte	$06,$45,$56,$45,$4e,$54,$a8   	; $ 89 EVENT(
>c1de	07 49 4e 4b 45 59 24 a8			.byte	$07,$49,$4e,$4b,$45,$59,$24,$a8	; $ 8a INKEY$(
>c1e6	04 41 53 43 a8				.byte	$04,$41,$53,$43,$a8           	; $ 8b ASC(
>c1eb	05 43 48 52 24 a8			.byte	$05,$43,$48,$52,$24,$a8       	; $ 8c CHR$(
>c1f1	04 53 51 52 a8				.byte	$04,$53,$51,$52,$a8           	; $ 8d SQR(
>c1f6	04 4c 45 4e a8				.byte	$04,$4c,$45,$4e,$a8           	; $ 8e LEN(
>c1fb	04 41 42 53 a8				.byte	$04,$41,$42,$53,$a8           	; $ 8f ABS(
>c200	04 53 47 4e a8				.byte	$04,$53,$47,$4e,$a8           	; $ 90 SGN(
>c205	04 56 41 4c a8				.byte	$04,$56,$41,$4c,$a8           	; $ 91 VAL(
>c20a	05 53 54 52 24 a8			.byte	$05,$53,$54,$52,$24,$a8       	; $ 92 STR$(
>c210	05 4d 49 44 24 a8			.byte	$05,$4d,$49,$44,$24,$a8       	; $ 93 MID$(
>c216	06 4c 45 46 54 24 a8			.byte	$06,$4c,$45,$46,$54,$24,$a8   	; $ 94 LEFT$(
>c21d	07 52 49 47 48 54 24 a8			.byte	$07,$52,$49,$47,$48,$54,$24,$a8	; $ 95 RIGHT$(
>c225	04 53 49 4e a8				.byte	$04,$53,$49,$4e,$a8           	; $ 96 SIN(
>c22a	04 43 4f 53 a8				.byte	$04,$43,$4f,$53,$a8           	; $ 97 COS(
>c22f	04 54 41 4e a8				.byte	$04,$54,$41,$4e,$a8           	; $ 98 TAN(
>c234	05 41 54 41 4e a8			.byte	$05,$41,$54,$41,$4e,$a8       	; $ 99 ATAN(
>c23a	05 53 51 52 54 a8			.byte	$05,$53,$51,$52,$54,$a8       	; $ 9a SQRT(
>c240	04 4c 4f 47 a8				.byte	$04,$4c,$4f,$47,$a8           	; $ 9b LOG(
>c245	04 45 58 50 a8				.byte	$04,$45,$58,$50,$a8           	; $ 9c EXP(
>c24a	04 4b 45 59 a8				.byte	$04,$4b,$45,$59,$a8           	; $ 9d KEY(
>c24f	00					.byte	$00                           	; $ 9e
>c250	00					.byte	$00                           	; $ 9f
>c251	00					.byte	$00                           	; $ a0
>c252	00					.byte	$00                           	; $ a1
>c253	00					.byte	$00                           	; $ a2
>c254	00					.byte	$00                           	; $ a3
>c255	00					.byte	$00                           	; $ a4
>c256	00					.byte	$00                           	; $ a5
>c257	00					.byte	$00                           	; $ a6
>c258	00					.byte	$00                           	; $ a7
>c259	00					.byte	$00                           	; $ a8
>c25a	00					.byte	$00                           	; $ a9
>c25b	00					.byte	$00                           	; $ aa
>c25c	00					.byte	$00                           	; $ ab
>c25d	00					.byte	$00                           	; $ ac
>c25e	00					.byte	$00                           	; $ ad
>c25f	00					.byte	$00                           	; $ ae
>c260	00					.byte	$00                           	; $ af
>c261	05 57 48 49 4c c5			.byte	$05,$57,$48,$49,$4c,$c5       	; $ b0 WHILE
>c267	04 57 45 4e c4				.byte	$04,$57,$45,$4e,$c4           	; $ b1 WEND
>c26c	02 49 c6				.byte	$02,$49,$c6                   	; $ b2 IF
>c26f	05 45 4e 44 49 c6			.byte	$05,$45,$4e,$44,$49,$c6       	; $ b3 ENDIF
>c275	02 44 cf				.byte	$02,$44,$cf                   	; $ b4 DO
>c278	04 4c 4f 4f d0				.byte	$04,$4c,$4f,$4f,$d0           	; $ b5 LOOP
>c27d	06 52 45 50 45 41 d4			.byte	$06,$52,$45,$50,$45,$41,$d4   	; $ b6 REPEAT
>c284	05 55 4e 54 49 cc			.byte	$05,$55,$4e,$54,$49,$cc       	; $ b7 UNTIL
>c28a	04 50 52 4f c3				.byte	$04,$50,$52,$4f,$c3           	; $ b8 PROC
>c28f	07 45 4e 44 50 52 4f c3			.byte	$07,$45,$4e,$44,$50,$52,$4f,$c3	; $ b9 ENDPROC
>c297	03 46 4f d2				.byte	$03,$46,$4f,$d2               	; $ ba FOR
>c29b	04 4e 45 58 d4				.byte	$04,$4e,$45,$58,$d4           	; $ bb NEXT
>c2a0	04 43 41 53 c5				.byte	$04,$43,$41,$53,$c5           	; $ bc CASE
>c2a5	07 45 4e 44 43 41 53 c5			.byte	$07,$45,$4e,$44,$43,$41,$53,$c5	; $ bd ENDCASE
>c2ad	00					.byte	$00                           	; $ be
>c2ae	04 54 48 45 ce				.byte	$04,$54,$48,$45,$ce           	; $ bf THEN
>c2b3	00					.byte	$00                           	; $ c0
>c2b4	00					.byte	$00                           	; $ c1
>c2b5	00					.byte	$00                           	; $ c2
>c2b6	00					.byte	$00                           	; $ c3
>c2b7	02 54 cf				.byte	$02,$54,$cf                   	; $ c4 TO
>c2ba	03 4c 45 d4				.byte	$03,$4c,$45,$d4               	; $ c5 LET
>c2be	05 50 52 49 4e d4			.byte	$05,$50,$52,$49,$4e,$d4       	; $ c6 PRINT
>c2c4	05 49 4e 50 55 d4			.byte	$05,$49,$4e,$50,$55,$d4       	; $ c7 INPUT
>c2ca	04 43 41 4c cc				.byte	$04,$43,$41,$4c,$cc           	; $ c8 CALL
>c2cf	03 53 59 d3				.byte	$03,$53,$59,$d3               	; $ c9 SYS
>c2d3	04 45 58 49 d4				.byte	$04,$45,$58,$49,$d4           	; $ ca EXIT
>c2d8	01 ac					.byte	$01,$ac                       	; $ cb ,
>c2da	01 bb					.byte	$01,$bb                       	; $ cc ;
>c2dc	01 ba					.byte	$01,$ba                       	; $ cd :
>c2de	01 a7					.byte	$01,$a7                       	; $ ce '
>c2e0	01 a9					.byte	$01,$a9                       	; $ cf )
>c2e2	04 52 45 41 c4				.byte	$04,$52,$45,$41,$c4           	; $ d0 READ
>c2e7	04 44 41 54 c1				.byte	$04,$44,$41,$54,$c1           	; $ d1 DATA
>c2ec	01 db					.byte	$01,$db                       	; $ d2 [
>c2ee	01 dd					.byte	$01,$dd                       	; $ d3 ]
>c2f0	01 a3					.byte	$01,$a3                       	; $ d4 #
>c2f2	01 ae					.byte	$01,$ae                       	; $ d5 .
>c2f4	04 45 4c 53 c5				.byte	$04,$45,$4c,$53,$c5           	; $ d6 ELSE
>c2f9	04 57 48 45 ce				.byte	$04,$57,$48,$45,$ce           	; $ d7 WHEN
>c2fe	06 44 4f 57 4e 54 cf			.byte	$06,$44,$4f,$57,$4e,$54,$cf   	; $ d8 DOWNTO
>c305	ff					.byte	$FF
.c306					Shift1TokenText:
>c306	05 43 4c 45 41 d2			.byte	$05,$43,$4c,$45,$41,$d2       	; $100 CLEAR
>c30c	03 4e 45 d7				.byte	$03,$4e,$45,$d7               	; $101 NEW
>c310	03 52 55 ce				.byte	$03,$52,$55,$ce               	; $102 RUN
>c314	04 53 54 4f d0				.byte	$04,$53,$54,$4f,$d0           	; $103 STOP
>c319	03 45 4e c4				.byte	$03,$45,$4e,$c4               	; $104 END
>c31d	06 41 53 53 45 52 d4			.byte	$06,$41,$53,$53,$45,$52,$d4   	; $105 ASSERT
>c324	04 4c 49 53 d4				.byte	$04,$4c,$49,$53,$d4           	; $106 LIST
>c329	04 53 41 56 c5				.byte	$04,$53,$41,$56,$c5           	; $107 SAVE
>c32e	04 4c 4f 41 c4				.byte	$04,$4c,$4f,$41,$c4           	; $108 LOAD
>c333	05 47 4f 53 55 c2			.byte	$05,$47,$4f,$53,$55,$c2       	; $109 GOSUB
>c339	04 47 4f 54 cf				.byte	$04,$47,$4f,$54,$cf           	; $10a GOTO
>c33e	06 52 45 54 55 52 ce			.byte	$06,$52,$45,$54,$55,$52,$ce   	; $10b RETURN
>c345	07 52 45 53 54 4f 52 c5			.byte	$07,$52,$45,$53,$54,$4f,$52,$c5	; $10c RESTORE
>c34d	03 44 49 cd				.byte	$03,$44,$49,$cd               	; $10d DIM
>c351	ff					.byte	$FF
.c352					BinaryPrecedence:
>c352	03					.byte	3		; +
>c353	03					.byte	3		; -
>c354	04					.byte	4		; *
>c355	04					.byte	4		; /
>c356	04					.byte	4		; >>
>c357	04					.byte	4		; <<
>c358	04					.byte	4		; %
>c359	04					.byte	4		; \
>c35a	01					.byte	1		; &
>c35b	01					.byte	1		; |
>c35c	01					.byte	1		; ^
>c35d	02					.byte	2		; >
>c35e	02					.byte	2		; >=
>c35f	02					.byte	2		; <
>c360	02					.byte	2		; <=
>c361	02					.byte	2		; <>
>c362	02					.byte	2		; =
>c363	05					.byte	5		; !
>c364	05					.byte	5		; ?

;******  Return to file: _include.inc


;******  Processing file: sources/generated/vectors_binary.asm

.c365					BinaryVectorTable:
>c365	0b c5					.word	Unimplemented            ; $20 +
>c367	54 c0					.word	SysTestMinus             ; $21 -
>c369	5c c0					.word	SysTestTimes             ; $22 *
>c36b	0b c5					.word	Unimplemented            ; $23 /
>c36d	0b c5					.word	Unimplemented            ; $24 >>
>c36f	0b c5					.word	Unimplemented            ; $25 <<
>c371	0b c5					.word	Unimplemented            ; $26 %
>c373	0b c5					.word	Unimplemented            ; $27 \
>c375	0b c5					.word	Unimplemented            ; $28 &
>c377	0b c5					.word	Unimplemented            ; $29 |
>c379	0b c5					.word	Unimplemented            ; $2a ^
>c37b	0b c5					.word	Unimplemented            ; $2b >
>c37d	0b c5					.word	Unimplemented            ; $2c >=
>c37f	0b c5					.word	Unimplemented            ; $2d <
>c381	0b c5					.word	Unimplemented            ; $2e <=
>c383	0b c5					.word	Unimplemented            ; $2f <>
>c385	0b c5					.word	Unimplemented            ; $30 =
>c387	0b c5					.word	Unimplemented            ; $31 !
>c389	0b c5					.word	Unimplemented            ; $32 ?

;******  Return to file: _include.inc


;******  Return to file: basic.asm

.c50b					Unimplemented:
.c50b	a9 ff		lda #$ff			lda 	#$FF
.c50d					ErrorHandler:
.c50d	a2 ee		ldx #$ee			ldx 	#$EE
.c50f	a0 ee		ldy #$ee			ldy 	#$EE
>c511	03						.byte 	3
.c512					_EHLoop:
.c512	80 fe		bra $c512			bra 	_EHLoop
>c38b							.align 	256
.c400					Program:
>c400	01 00 00 00 00 00 00 00				.binary "build/tokenised.dat"
>c408	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
;	...repeated 14 times (224 bytes)...
>c4f8	00 00 00 00 00 00 00 00 0a 64 00 c6 42 21 43 22
>c508	44 c0 00

;******  End of listing
