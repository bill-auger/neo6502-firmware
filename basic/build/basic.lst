
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -b --mr65c02 -Wall -L build/basic.lst -o build/basic.bin basic.asm
; Sat Nov 25 16:39:27 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.inc


;******  Processing file: sources/00data/00data_config.inc


;******  Return to file: _include.inc


;******  Processing file: sources/00data/01data.inc


;******  Return to file: _include.inc


;******  Processing file: sources/generated/kwdconst.inc

=$20					KWD_PLUS                           = $20 ; +
=$21					KWD_MINUS                          = $21 ; -
=$22					KWD_ASTERISK                       = $22 ; *
=$23					KWD_SLASH                          = $23 ; /
=$24					KWD_GREATERGREATER                 = $24 ; >>
=$25					KWD_LESSLESS                       = $25 ; <<
=$26					KWD_PERCENT                        = $26 ; %
=$27					KWD_BACKSLASH                      = $27 ; \
=$28					KWD_AMPERSAND                      = $28 ; &
=$29					KWD_VBAR                           = $29 ; |
=$2a					KWD_HAT                            = $2a ; ^
=$2b					KWD_GREATER                        = $2b ; >
=$2c					KWD_GREATEREQUAL                   = $2c ; >=
=$2d					KWD_LESS                           = $2d ; <
=$2e					KWD_LESSEQUAL                      = $2e ; <=
=$2f					KWD_LESSGREATER                    = $2f ; <>
=$30					KWD_EQUAL                          = $30 ; =
=$31					KWD_PLING                          = $31 ; !
=$32					KWD_QMARK                          = $32 ; ?
=$80					KWD_SYS_STR                        = $80 ; !!str
=$81					KWD_SYS_DEC                        = $81 ; !!dec
=$82					KWD_DOLLAR                         = $82 ; $
=$83					KWD_LPAREN                         = $83 ; (
=$84					KWD_RANDLPAREN                     = $84 ; rand(
=$85					KWD_RNDLPAREN                      = $85 ; rnd(
=$86					KWD_ISVALLPAREN                    = $86 ; isval(
=$87					KWD_FRACLPAREN                     = $87 ; frac(
=$88					KWD_INTLPAREN                      = $88 ; int(
=$89					KWD_TIME                           = $89 ; time
=$8a					KWD_EVENTLPAREN                    = $8a ; event(
=$8b					KWD_INKEYDOLLARLPAREN              = $8b ; inkey$(
=$8c					KWD_ASCLPAREN                      = $8c ; asc(
=$8d					KWD_CHRDOLLARLPAREN                = $8d ; chr$(
=$8e					KWD_SQRLPAREN                      = $8e ; sqr(
=$8f					KWD_LENLPAREN                      = $8f ; len(
=$90					KWD_ABSLPAREN                      = $90 ; abs(
=$91					KWD_SGNLPAREN                      = $91 ; sgn(
=$92					KWD_VALLPAREN                      = $92 ; val(
=$93					KWD_STRDOLLARLPAREN                = $93 ; str$(
=$94					KWD_MIDDOLLARLPAREN                = $94 ; mid$(
=$95					KWD_LEFTDOLLARLPAREN               = $95 ; left$(
=$96					KWD_RIGHTDOLLARLPAREN              = $96 ; right$(
=$97					KWD_SINLPAREN                      = $97 ; sin(
=$98					KWD_COSLPAREN                      = $98 ; cos(
=$99					KWD_TANLPAREN                      = $99 ; tan(
=$9a					KWD_ATANLPAREN                     = $9a ; atan(
=$9b					KWD_SQRTLPAREN                     = $9b ; sqrt(
=$9c					KWD_LOGLPAREN                      = $9c ; log(
=$9d					KWD_EXPLPAREN                      = $9d ; exp(
=$9e					KWD_KEYLPAREN                      = $9e ; key(
=$b0					KWD_WHILE                          = $b0 ; while
=$b1					KWD_WEND                           = $b1 ; wend
=$b2					KWD_IF                             = $b2 ; if
=$b3					KWD_ENDIF                          = $b3 ; endif
=$b4					KWD_DO                             = $b4 ; do
=$b5					KWD_LOOP                           = $b5 ; loop
=$b6					KWD_REPEAT                         = $b6 ; repeat
=$b7					KWD_UNTIL                          = $b7 ; until
=$b8					KWD_PROC                           = $b8 ; proc
=$b9					KWD_ENDPROC                        = $b9 ; endproc
=$ba					KWD_FOR                            = $ba ; for
=$bb					KWD_NEXT                           = $bb ; next
=$bc					KWD_CASE                           = $bc ; case
=$bd					KWD_ENDCASE                        = $bd ; endcase
=$be					KWD_SYS_UN1                        = $be ; !!un1
=$bf					KWD_THEN                           = $bf ; then
=$c0					KWD_SYS_END                        = $c0 ; !!end
=$c1					KWD_SYS_SH1                        = $c1 ; !!sh1
=$c2					KWD_SYS_SH2                        = $c2 ; !!sh2
=$c3					KWD_TO                             = $c3 ; to
=$c4					KWD_STEP                           = $c4 ; step
=$c5					KWD_LET                            = $c5 ; let
=$c6					KWD_PRINT                          = $c6 ; print
=$c7					KWD_INPUT                          = $c7 ; input
=$c8					KWD_CALL                           = $c8 ; call
=$c9					KWD_SYS                            = $c9 ; sys
=$ca					KWD_EXIT                           = $ca ; exit
=$cb					KWD_COMMA                          = $cb ; ,
=$cc					KWD_SEMICOLON                      = $cc ; ;
=$cd					KWD_COLON                          = $cd ; :
=$ce					KWD_SQUOTE                         = $ce ; '
=$cf					KWD_RPAREN                         = $cf ; )
=$d0					KWD_READ                           = $d0 ; read
=$d1					KWD_DATA                           = $d1 ; data
=$d2					KWD_LSQ                            = $d2 ; [
=$d3					KWD_RSQ                            = $d3 ; ]
=$d4					KWD_HASH                           = $d4 ; #
=$d5					KWD_PERIOD                         = $d5 ; .
=$d6					KWD_ELSE                           = $d6 ; else
=$d7					KWD_WHEN                           = $d7 ; when
=$100					KWD_CLEAR                          = $100 ; clear
=$101					KWD_NEW                            = $101 ; new
=$102					KWD_RUN                            = $102 ; run
=$103					KWD_STOP                           = $103 ; stop
=$104					KWD_END                            = $104 ; end
=$105					KWD_ASSERT                         = $105 ; assert
=$106					KWD_LIST                           = $106 ; list
=$107					KWD_SAVE                           = $107 ; save
=$108					KWD_LOAD                           = $108 ; load
=$109					KWD_GOSUB                          = $109 ; gosub
=$10a					KWD_GOTO                           = $10a ; goto
=$10b					KWD_RETURN                         = $10b ; return
=$10c					KWD_RESTORE                        = $10c ; restore
=$10d					KWD_DIM                            = $10d ; dim

;******  Return to file: _include.inc


;******  Processing file: sources/generated/neo6502.inc

=$ff00					ControlPort = $ff00
=$ffee					ReadCharacter = $ffee
=$fff1					WriteCharacter = $fff1
=$fff4					WaitMessage = $fff4
=$fff7					SendMessage = $fff7

;******  Return to file: _include.inc


;******  Processing file: sources/generated/kwdtext.asm

.c208					BinaryTokenText:
>c208	01 ab					.byte	$01,$ab                       	; $ 20 +
>c20a	01 ad					.byte	$01,$ad                       	; $ 21 -
>c20c	01 aa					.byte	$01,$aa                       	; $ 22 *
>c20e	01 af					.byte	$01,$af                       	; $ 23 /
>c210	02 3e be				.byte	$02,$3e,$be                   	; $ 24 >>
>c213	02 3c bc				.byte	$02,$3c,$bc                   	; $ 25 <<
>c216	01 a5					.byte	$01,$a5                       	; $ 26 %
>c218	01 dc					.byte	$01,$dc                       	; $ 27 \
>c21a	01 a6					.byte	$01,$a6                       	; $ 28 &
>c21c	01 fc					.byte	$01,$fc                       	; $ 29 |
>c21e	01 de					.byte	$01,$de                       	; $ 2a ^
>c220	01 be					.byte	$01,$be                       	; $ 2b >
>c222	02 3e bd				.byte	$02,$3e,$bd                   	; $ 2c >=
>c225	01 bc					.byte	$01,$bc                       	; $ 2d <
>c227	02 3c bd				.byte	$02,$3c,$bd                   	; $ 2e <=
>c22a	02 3c be				.byte	$02,$3c,$be                   	; $ 2f <>
>c22d	01 bd					.byte	$01,$bd                       	; $ 30 =
>c22f	01 a1					.byte	$01,$a1                       	; $ 31 !
>c231	01 bf					.byte	$01,$bf                       	; $ 32 ?
>c233	ff					.byte	$FF
.c234					BaseTokenText:
>c234	00					.byte	$00                           	; $ 80
>c235	00					.byte	$00                           	; $ 81
>c236	01 a4					.byte	$01,$a4                       	; $ 82 $
>c238	01 a8					.byte	$01,$a8                       	; $ 83 (
>c23a	05 52 41 4e 44 a8			.byte	$05,$52,$41,$4e,$44,$a8       	; $ 84 RAND(
>c240	04 52 4e 44 a8				.byte	$04,$52,$4e,$44,$a8           	; $ 85 RND(
>c245	06 49 53 56 41 4c a8			.byte	$06,$49,$53,$56,$41,$4c,$a8   	; $ 86 ISVAL(
>c24c	05 46 52 41 43 a8			.byte	$05,$46,$52,$41,$43,$a8       	; $ 87 FRAC(
>c252	04 49 4e 54 a8				.byte	$04,$49,$4e,$54,$a8           	; $ 88 INT(
>c257	04 54 49 4d c5				.byte	$04,$54,$49,$4d,$c5           	; $ 89 TIME
>c25c	06 45 56 45 4e 54 a8			.byte	$06,$45,$56,$45,$4e,$54,$a8   	; $ 8a EVENT(
>c263	07 49 4e 4b 45 59 24 a8			.byte	$07,$49,$4e,$4b,$45,$59,$24,$a8	; $ 8b INKEY$(
>c26b	04 41 53 43 a8				.byte	$04,$41,$53,$43,$a8           	; $ 8c ASC(
>c270	05 43 48 52 24 a8			.byte	$05,$43,$48,$52,$24,$a8       	; $ 8d CHR$(
>c276	04 53 51 52 a8				.byte	$04,$53,$51,$52,$a8           	; $ 8e SQR(
>c27b	04 4c 45 4e a8				.byte	$04,$4c,$45,$4e,$a8           	; $ 8f LEN(
>c280	04 41 42 53 a8				.byte	$04,$41,$42,$53,$a8           	; $ 90 ABS(
>c285	04 53 47 4e a8				.byte	$04,$53,$47,$4e,$a8           	; $ 91 SGN(
>c28a	04 56 41 4c a8				.byte	$04,$56,$41,$4c,$a8           	; $ 92 VAL(
>c28f	05 53 54 52 24 a8			.byte	$05,$53,$54,$52,$24,$a8       	; $ 93 STR$(
>c295	05 4d 49 44 24 a8			.byte	$05,$4d,$49,$44,$24,$a8       	; $ 94 MID$(
>c29b	06 4c 45 46 54 24 a8			.byte	$06,$4c,$45,$46,$54,$24,$a8   	; $ 95 LEFT$(
>c2a2	07 52 49 47 48 54 24 a8			.byte	$07,$52,$49,$47,$48,$54,$24,$a8	; $ 96 RIGHT$(
>c2aa	04 53 49 4e a8				.byte	$04,$53,$49,$4e,$a8           	; $ 97 SIN(
>c2af	04 43 4f 53 a8				.byte	$04,$43,$4f,$53,$a8           	; $ 98 COS(
>c2b4	04 54 41 4e a8				.byte	$04,$54,$41,$4e,$a8           	; $ 99 TAN(
>c2b9	05 41 54 41 4e a8			.byte	$05,$41,$54,$41,$4e,$a8       	; $ 9a ATAN(
>c2bf	05 53 51 52 54 a8			.byte	$05,$53,$51,$52,$54,$a8       	; $ 9b SQRT(
>c2c5	04 4c 4f 47 a8				.byte	$04,$4c,$4f,$47,$a8           	; $ 9c LOG(
>c2ca	04 45 58 50 a8				.byte	$04,$45,$58,$50,$a8           	; $ 9d EXP(
>c2cf	04 4b 45 59 a8				.byte	$04,$4b,$45,$59,$a8           	; $ 9e KEY(
>c2d4	00					.byte	$00                           	; $ 9f
>c2d5	00					.byte	$00                           	; $ a0
>c2d6	00					.byte	$00                           	; $ a1
>c2d7	00					.byte	$00                           	; $ a2
>c2d8	00					.byte	$00                           	; $ a3
>c2d9	00					.byte	$00                           	; $ a4
>c2da	00					.byte	$00                           	; $ a5
>c2db	00					.byte	$00                           	; $ a6
>c2dc	00					.byte	$00                           	; $ a7
>c2dd	00					.byte	$00                           	; $ a8
>c2de	00					.byte	$00                           	; $ a9
>c2df	00					.byte	$00                           	; $ aa
>c2e0	00					.byte	$00                           	; $ ab
>c2e1	00					.byte	$00                           	; $ ac
>c2e2	00					.byte	$00                           	; $ ad
>c2e3	00					.byte	$00                           	; $ ae
>c2e4	00					.byte	$00                           	; $ af
>c2e5	05 57 48 49 4c c5			.byte	$05,$57,$48,$49,$4c,$c5       	; $ b0 WHILE
>c2eb	04 57 45 4e c4				.byte	$04,$57,$45,$4e,$c4           	; $ b1 WEND
>c2f0	02 49 c6				.byte	$02,$49,$c6                   	; $ b2 IF
>c2f3	05 45 4e 44 49 c6			.byte	$05,$45,$4e,$44,$49,$c6       	; $ b3 ENDIF
>c2f9	02 44 cf				.byte	$02,$44,$cf                   	; $ b4 DO
>c2fc	04 4c 4f 4f d0				.byte	$04,$4c,$4f,$4f,$d0           	; $ b5 LOOP
>c301	06 52 45 50 45 41 d4			.byte	$06,$52,$45,$50,$45,$41,$d4   	; $ b6 REPEAT
>c308	05 55 4e 54 49 cc			.byte	$05,$55,$4e,$54,$49,$cc       	; $ b7 UNTIL
>c30e	04 50 52 4f c3				.byte	$04,$50,$52,$4f,$c3           	; $ b8 PROC
>c313	07 45 4e 44 50 52 4f c3			.byte	$07,$45,$4e,$44,$50,$52,$4f,$c3	; $ b9 ENDPROC
>c31b	03 46 4f d2				.byte	$03,$46,$4f,$d2               	; $ ba FOR
>c31f	04 4e 45 58 d4				.byte	$04,$4e,$45,$58,$d4           	; $ bb NEXT
>c324	04 43 41 53 c5				.byte	$04,$43,$41,$53,$c5           	; $ bc CASE
>c329	07 45 4e 44 43 41 53 c5			.byte	$07,$45,$4e,$44,$43,$41,$53,$c5	; $ bd ENDCASE
>c331	00					.byte	$00                           	; $ be
>c332	04 54 48 45 ce				.byte	$04,$54,$48,$45,$ce           	; $ bf THEN
>c337	00					.byte	$00                           	; $ c0
>c338	00					.byte	$00                           	; $ c1
>c339	00					.byte	$00                           	; $ c2
>c33a	02 54 cf				.byte	$02,$54,$cf                   	; $ c3 TO
>c33d	04 53 54 45 d0				.byte	$04,$53,$54,$45,$d0           	; $ c4 STEP
>c342	03 4c 45 d4				.byte	$03,$4c,$45,$d4               	; $ c5 LET
>c346	05 50 52 49 4e d4			.byte	$05,$50,$52,$49,$4e,$d4       	; $ c6 PRINT
>c34c	05 49 4e 50 55 d4			.byte	$05,$49,$4e,$50,$55,$d4       	; $ c7 INPUT
>c352	04 43 41 4c cc				.byte	$04,$43,$41,$4c,$cc           	; $ c8 CALL
>c357	03 53 59 d3				.byte	$03,$53,$59,$d3               	; $ c9 SYS
>c35b	04 45 58 49 d4				.byte	$04,$45,$58,$49,$d4           	; $ ca EXIT
>c360	01 ac					.byte	$01,$ac                       	; $ cb ,
>c362	01 bb					.byte	$01,$bb                       	; $ cc ;
>c364	01 ba					.byte	$01,$ba                       	; $ cd :
>c366	01 a7					.byte	$01,$a7                       	; $ ce '
>c368	01 a9					.byte	$01,$a9                       	; $ cf )
>c36a	04 52 45 41 c4				.byte	$04,$52,$45,$41,$c4           	; $ d0 READ
>c36f	04 44 41 54 c1				.byte	$04,$44,$41,$54,$c1           	; $ d1 DATA
>c374	01 db					.byte	$01,$db                       	; $ d2 [
>c376	01 dd					.byte	$01,$dd                       	; $ d3 ]
>c378	01 a3					.byte	$01,$a3                       	; $ d4 #
>c37a	01 ae					.byte	$01,$ae                       	; $ d5 .
>c37c	04 45 4c 53 c5				.byte	$04,$45,$4c,$53,$c5           	; $ d6 ELSE
>c381	04 57 48 45 ce				.byte	$04,$57,$48,$45,$ce           	; $ d7 WHEN
>c386	ff					.byte	$FF
.c387					Shift1TokenText:
>c387	05 43 4c 45 41 d2			.byte	$05,$43,$4c,$45,$41,$d2       	; $100 CLEAR
>c38d	03 4e 45 d7				.byte	$03,$4e,$45,$d7               	; $101 NEW
>c391	03 52 55 ce				.byte	$03,$52,$55,$ce               	; $102 RUN
>c395	04 53 54 4f d0				.byte	$04,$53,$54,$4f,$d0           	; $103 STOP
>c39a	03 45 4e c4				.byte	$03,$45,$4e,$c4               	; $104 END
>c39e	06 41 53 53 45 52 d4			.byte	$06,$41,$53,$53,$45,$52,$d4   	; $105 ASSERT
>c3a5	04 4c 49 53 d4				.byte	$04,$4c,$49,$53,$d4           	; $106 LIST
>c3aa	04 53 41 56 c5				.byte	$04,$53,$41,$56,$c5           	; $107 SAVE
>c3af	04 4c 4f 41 c4				.byte	$04,$4c,$4f,$41,$c4           	; $108 LOAD
>c3b4	05 47 4f 53 55 c2			.byte	$05,$47,$4f,$53,$55,$c2       	; $109 GOSUB
>c3ba	04 47 4f 54 cf				.byte	$04,$47,$4f,$54,$cf           	; $10a GOTO
>c3bf	06 52 45 54 55 52 ce			.byte	$06,$52,$45,$54,$55,$52,$ce   	; $10b RETURN
>c3c6	07 52 45 53 54 4f 52 c5			.byte	$07,$52,$45,$53,$54,$4f,$52,$c5	; $10c RESTORE
>c3ce	03 44 49 cd				.byte	$03,$44,$49,$cd               	; $10d DIM
>c3d2	ff					.byte	$FF
.c3d3					BinaryPrecedence:
>c3d3	03					.byte	3		; +
>c3d4	03					.byte	3		; -
>c3d5	04					.byte	4		; *
>c3d6	04					.byte	4		; /
>c3d7	04					.byte	4		; >>
>c3d8	04					.byte	4		; <<
>c3d9	04					.byte	4		; %
>c3da	04					.byte	4		; \
>c3db	01					.byte	1		; &
>c3dc	01					.byte	1		; |
>c3dd	01					.byte	1		; ^
>c3de	02					.byte	2		; >
>c3df	02					.byte	2		; >=
>c3e0	02					.byte	2		; <
>c3e1	02					.byte	2		; <=
>c3e2	02					.byte	2		; <>
>c3e3	02					.byte	2		; =
>c3e4	05					.byte	5		; !
>c3e5	05					.byte	5		; ?

;******  Return to file: _include.inc


;******  Return to file: basic.asm

>c000	03				boot:	.byte 	$03
.c001	80 fd		bra $c000			bra 	boot
>c003							.align 	256
.c100					Program:
>c100	01 00 00 00 00 00 00 00				.binary "build/tokenised.dat"
>c108	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
;	...repeated 14 times (224 bytes)...
>c1f8	00 00 00 00 00 00 00 00 07 64 00 c6 44 4b c0 00

;******  End of listing
