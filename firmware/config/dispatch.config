// ***************************************************************************************
// ***************************************************************************************
//
//      Name :      dispatch.config
//      Authors :   Paul Robson (paul@robsons.org.uk)
//      Date :      22nd November 2023
//      Reviewed :  No
//      Purpose :   Dispatched for commands
//
// ***************************************************************************************
// ***************************************************************************************

// ***************************************************************************************
//
//									Group 1 (System)
//
// ***************************************************************************************

group 1
	function 0 										// Function 0 resets the interface
		DSPReset();

	function 1 										// Function 1 copies the 32 bit system timer
		*((uint32_t *)DPARAMS) = TMRRead(); 		// (assumes littleendian)

// ***************************************************************************************
//
//									Group 0 (Console)
//
// ***************************************************************************************

group 2
	function 0 										// Function 0 is console out
		CONWrite(*DPARAMS);
	function 1 										// Function 1 is console in
		*(DPARAMS) = KBDGetKey();
	function 2 										// Function 2 is key available in queue
		*(DPARAMS) = KBDIsKeyAvailable() ? 0xFF: 0;

// ***************************************************************************************
//
//									Group 2 (File I/O)
//
// ***************************************************************************************

group 3

// ***************************************************************************************
//
//									Group 3 (Mathematics)
//
// ***************************************************************************************

group 4
	function 0 										// Add
		if (MATHIsFloatBinary()) {
			MATHWriteFloat(MATHReadFloat(MATH_REG1)+MATHReadFloat(MATH_REG2),MATH_REG1);
		} else {
			MATHWriteInt(MATHReadInt(MATH_REG1)+MATHReadInt(MATH_REG2),MATH_REG1);
		}

	function 1 										// Subtract
		if (MATHIsFloatBinary()) {
			MATHWriteFloat(MATHReadFloat(MATH_REG1)-MATHReadFloat(MATH_REG2),MATH_REG1);
		} else {
			MATHWriteInt(MATHReadInt(MATH_REG1)-MATHReadInt(MATH_REG2),MATH_REG1);
		}

	function 2 										// Multiply
		if (MATHIsFloatBinary()) {
			MATHWriteFloat(MATHReadFloat(MATH_REG1)*MATHReadFloat(MATH_REG2),MATH_REG1);
		} else {
			MATHWriteInt(MATHReadInt(MATH_REG1)*MATHReadInt(MATH_REG2),MATH_REG1);
		}

	function 3 										// Float Divide
		f1 = MATHReadFloat(MATH_REG2);
		if (f1 == 0.0) {
			*DERROR = 1;
		} else {
			MATHWriteFloat(MATHReadFloat(MATH_REG1)/f1,MATH_REG1);
		}

	function 4 										// Int Divide
		i1 = MATHReadInt(MATH_REG1);
		i2 = MATHReadInt(MATH_REG2);
		if (i2 == 0) {
			*DERROR = 1;
		} else {
			MATHWriteInt(i1/i2,MATH_REG1);
		}

	function 5 										// Int Modulus
		i1 = MATHReadInt(MATH_REG1);
		i2 = MATHReadInt(MATH_REG2);
		if (i2 == 0) {
			*DERROR = 1;
		} else {
			MATHWriteInt(abs(i1) % abs(i2),MATH_REG1);
		}

	function 6 										// Compare
		*DSTATUS = 0;
		if (MATHIsFloatBinary()) {
			f1 = MATHReadFloat(MATH_REG1);
			f2 = MATHReadFloat(MATH_REG2);
			float diff = (float_abs(f1)+float_abs(f2)) * 0.0000001f;
			if (float_abs(f1-f2) >= diff) {
				*DSTATUS = (f1 < f2 ? 0xFF:0x01);
			} 
		} else {
			i1 = MATHReadInt(MATH_REG1);
			i2 = MATHReadInt(MATH_REG2);
			if (i1 != i2) *DSTATUS = (i1 < i2 ? 0xFF:0x01);
		}

	function 16  									// Unary negate 
		if (MATHIsFloatUnary()) {
			MATHWriteFloat(-MATHReadFloat(MATH_REG1),MATH_REG1);
		} else {
			MATHWriteInt(-MATHReadInt(MATH_REG1),MATH_REG1);
		}
	function 32 									// Append decimal digits, convert to float
		MATHProcessDecimal(DCOMMAND);
		
// 6 	compare

// 17 	random.float
// 18  random.int
// 19 	abs
// 20 	int
// 21 	frac
// 22 	sqr
// 23 	sin
// 24 	cos
// 25 	tan
// 26 	atan
// 27 	log
// 28 	exp

